# Drop collinear Z variables
formula <- as.formula(paste0(Y,
" ~ ",
X, " + ",
paste(Q, collapse = " + "), " + ",
paste(Z, collapse = " + "),
" - 1"
))
model <- lm_robust(formula,
se_type = "stata",
clusters = clustervar,
data = df)
out <- summary(model)
na_idx <- which(is.na(out$coefficients[, "Estimate"]))
df <- df[, !names(df) %in% names(na_idx)]
# Re-define vars
Y <- "Y"
X <- "X"
Q <- names(df)[grep("Q.*", names(df))]
Z <- names(df)[grep("Z.*", names(df))]
cl <- "clustervar"
# Re-run the reg just to make sure
formula <- as.formula(paste0(Y,
" ~ ",
X, " + ",
paste(Q, collapse = " + "), " + ",
paste(Z, collapse = " + "),
" - 1"))
model <- lm_robust(formula,
se_type = "stata",
clusters = clustervar,
data = df)
summary(model)
## Long regression
model <- lm_robust(formula,
se_type = "stata",
clusters = clustervar,
data = df)
coefL <- model$coefficients["X"]
tstatL <- model$coefficients["X"] / model$std.error["X"]
## Short regression
formula <- as.formula(paste0(Y,
" ~ ",
X, " + ",
paste(Q, collapse = " + "),
" - 1"))
model <- lm_robust(formula,
se_type = "stata",
clusters = clustervar,
data = df)
coefS <- model$coefficients["X"]
tstatS <- model$coefficients["X"] / model$std.error["X"]
## Variables for bivariate test
df <- df %>% filter(!is.na(model$fitted.values))
df <- df[ , c(Y, X, Q, Z, cl)]
## Statistics
# R square Y on X given Q
formula <- as.formula(paste0(Y,
" ~ ",
paste(Q, collapse = " + "),
" - 1"))
model <- lm(formula, data = df)
MqY <- model$residuals
formula <- as.formula(paste0(X,
" ~ ",
paste(Q, collapse = " + "),
" - 1"))
model <- lm(formula, data = df)
MqX <- model$residuals
model <- lm(MqY ~ MqX - 1)
R2_XYgivenQ <- summary(model)$r.squared
# R square X on Z given Q
reg <- function(z) {
formula <- as.formula(paste0(z, " ~ ",
paste(Q, collapse = " + "),
" - 1"))
model <- lm(formula, data = df)
out <- model$residuals
return(out)
}
MqZ <- sapply(Z, reg)
model <- lm(MqX ~ MqZ - 1)
R2_ZXgivenQ <- summary(model)$r.squared
# Export results to Excel
NQ <- length( names(df)[grep("Q.*", names(df))] )
NZ <- length( names(df)[grep("Z.*", names(df))] )
# Get the number of obs
formula <- as.formula(paste0(Y,
" ~ ",
X, " + ",
paste(Q, collapse = " + "), " + ",
paste(Z, collapse = " + "),
" - 1"))
model <- lm_robust(formula,
se_type = "stata",
clusters = clustervar,
data = df)
N <- model$nobs
temp <- model$coefficients
Betlong <- data.frame(y1 = as.numeric(temp))
rownames(Betlong) <- names(temp)
Covlong <- model$vcov
# Save results
wb <- createWorkbook()
addWorksheet(wb, "Covlong")
writeData(wb, "Covlong", Covlong, rowNames = TRUE)
addWorksheet(wb, "Betlong")
writeData(wb, "Betlong", Betlong, rowNames = TRUE)
addWorksheet(wb, "Design")
writeData(wb, "Design", df)
# Specifications
specifications <- data.frame(
Specification = c("Paper", "Baseline analysis", "Y variable", "X variable", "Q variable", "Z variable", "Other"),
Value = c("Macchiavello, Morjaria (AER, September 2015)", "Table 5, Column 8", "log(Value)",
"log(# previous interactions)", "Season FEs, relationship FEs, max of past auction prices",
"Buyer x season FEs", "SEs clustered by seller; baseline includes Y,X,Q, and Z is added for bivariate test")
)
addWorksheet(wb, "Specification")
writeData(wb, "Specification", specifications)
# Statistics
statistics <- data.frame(
Statistic = c("Number of observations",
"Number of baseline controls Q",
"Number of potential controls Z",
"Betahat long",
"t-statistic long",
"Betahat short",
"t-statistic short (Matlab)",
"t-statistic short (Stata)",
"R-squared of X on Y given Q",
"R-squared of Z on X given Q",
"Correlation between long and short"),
Value = c(N,
NQ,
NZ,
coefL,
NA,
coefS,
NA,
tstatS,
R2_XYgivenQ,
R2_ZXgivenQ,
NA))
addWorksheet(wb, "Statistic")
writeData(wb, "Statistic", statistics)
# QC
idx <- statistics$Statistic %in% c("Betahat long", "Betahat short", "t-statistic short (Stata)")
qc <- statistics[idx,]
addWorksheet(wb, "QC")
writeData(wb, "QC", qc)
# Save xlsx
saveWorkbook(wb, file = paste0(directory_home, "/Bivariatedata1.xlsx"), overwrite = TRUE)
source("~/Documents/Mon_travail/MY_PHD/Soonwoo/proj_many_controls/econ_replication/li_muller_2021_in_R/C1_Data_preparation.R")
rm(list = ls())
library(R.matlab)
library(openxlsx)
library(dplyr)
source("utils.R")
## Set working directory here
directory_home <- "/Users/eddiewu/Documents/Mon_travail/MY_PHD/Soonwoo/proj_many_controls/econ_replication/li_muller_2021_in_R"
setwd(directory_home)
data_path <- paste0(directory_home, "/data")
output_path <- paste0(directory_home, "/my_output")
rm(list = ls())
library(R.matlab)
library(openxlsx)
library(dplyr)
source("utils.R")
## Set working directory here
directory_home <- "/Users/eddiewu/Documents/Mon_travail/MY_PHD/Soonwoo/proj_many_controls/econ_replication/li_muller_2021_in_R"
setwd(directory_home)
output_path <- paste0(directory_home, "/my_output")
cv_path <- paste0(directory_home, "/critical_values")
##
location_CV <- file.path(cv_path, "CV_vals.mat")
CV <- readMat(location_CV)[["CV"]]
output_path <- paste0(directory_home, "/my_output")
cv_path <- paste0(directory_home, "/critical_values")
##
location_CV <- file.path(cv_path, "CV_vals.mat")
CV <- readMat(location_CV)[["CV"]]
examples <- "Bivariatedata1.xlsx"
data <- file.path(output_path, examples)
alpha <- 0.05
##
ds <- read.xlsx(data, sheet = "Design")
##
varnames <- names(ds)
Y <- as.numeric(ds$Y)
X <- as.numeric(ds$X)
Q_ind <- grepl("Q", varnames)
Q <- as.matrix(ds[, Q_ind])
KQ <- ncol(Q)
Z_ind <- grepl("Z", varnames)
Z <- as.matrix(ds[, Z_ind])
XQ <- cbind(X, Q)
lambda <- solve(t(XQ) %*% XQ) %*% (t(XQ) %*% Z)
lambda <- lambda[1, ]
MqY <- Y - Q %*% solve(t(Q) %*% Q) %*% (t(Q) %*% Y)
MqX <- X - Q %*% solve(t(Q) %*% Q) %*% (t(Q) %*% X)
MqZ <- Z - Q %*% solve(t(Q) %*% Q) %*% (t(Q) %*% Z)
MxqY <- Y - XQ %*% solve(t(XQ) %*% XQ) %*% (t(XQ) %*% Y)
N <- length(Y)
### Errors from short regression
## Clustered standard errors
cluster_groups <- as.numeric(ds$clustervar)
cluster_groups_unique <- unique(cluster_groups)
P <- length(cluster_groups_unique)
np <- vector("list", P)
for (ii in 1:P) {
np[[ii]] <- which(cluster_groups == cluster_groups_unique[ii])
}
##
ehat_short <- Y - XQ %*% solve(t(XQ) %*% XQ) %*% (t(XQ) %*% Y)
sighat_e <- matrix(0, nrow = N, ncol = N)
for (ii in 1:P) {
tempind <- np[[ii]]
temp <- ehat_short[tempind] %*% t(ehat_short[tempind])
sighat_e[tempind, tempind] <- (temp + t(temp)) / 2
}
##
QZ <- cbind(Q, Z)
XQZ <- cbind(X, Q, Z)
DLong <- solve(t(XQZ) %*% XQZ) %*% t(XQZ)
DLong <- DLong[1, ]
DShort <- solve(t(XQ) %*% XQ) %*% t(XQ)
DShort <- DShort[1, ]
D <- rbind(DLong, DShort)
rm(Dsig)
Dsig <- D
VarLS <- Dsig %*% sighat_e %*% t(Dsig)
sig_biv <- list(sigL2 = VarLS[1, 1], sigLS = VarLS[1, 2], sigS2 = VarLS[2, 2])
## Coefficients
coef_biv <- list(betaL = as.numeric(DLong %*% Y),
betaS = as.numeric(DShort %*% Y))
# QC
QC <- read.xlsx(data, sheet = "QC")
QC <- as.numeric(QC$Value)
stopifnot(abs((QC[1] - coef_biv$betaL) / QC[1]) < 10^(-3))
stopifnot(abs((QC[2] - coef_biv$betaS) / QC[2]) < 10^(-3))
# Long t-stat
tstatL <- coef_biv$betaL / sqrt(sig_biv$sigL2)
##
#
R2_grid <- seq(0, 0.35, by = 0.00001)
Test <- numeric(length(R2_grid))
#
r0 <- norm(MqY, "F") * sqrt( t(lambda) %*% solve(t(MqZ) %*% MqZ) %*% lambda )
ii <- 1*(alpha == 0.01) + 2*(alpha == 0.05) + 3*(alpha == 0.1)
CV_struct <- CV[ , 1, ii]
##
#
for (iTest in 1:length(R2_grid)) {
R2_bound <- R2_grid[iTest]
r_d <- r0 * sqrt(R2_bound)
Test[iTest] <- logLik_GLR(coef_biv$betaL, coef_biv$betaS, sig_biv, r_d, CV_struct)
}
Test1 <- c(Test[-1], -999)
Testm1 <- c(-999, Test[-length(Test)])
Cutoffkappa <- data.frame(
Test = Test[(Test != Test1) | (Test != Testm1)],
R2_grid = R2_grid[(Test != Test1) | (Test != Testm1)]
)
Cutoffkappa$R2_grid <- Cutoffkappa$R2_grid * norm(MqY, "F")^2
data
# Write the results to Excel
wb <- loadWorkbook(data)
addWorksheet(wb, sheetName = "Kappabound")
writeData(wb, sheet = "Kappabound", x = Cutoffkappa, colNames = FALSE, rowNames = FALSE)
saveWorkbook(wb, file = data, overwrite = TRUE)
idata <- 1
sheet_name <- as.character(idata)
results <- data.frame(
Kappa2 = Cutoffkappa$R2_grid[2],
sqrtKappa2_div_N = sqrt(Cutoffkappa$R2_grid[2] / N),
Kappa2_div_normMxqY2 = Cutoffkappa$R2_grid[2] / (norm(MxqY, "F")^2)
)
results <- t(results)
wb <- createWorkbook()
addWorksheet(wb, sheetName = sheet_name)
writeData(wb, sheet = sheet_name, x = results, colNames = FALSE, rowNames = FALSE)
saveWorkbook(wb, file = file.path(output_path, 'Empirical.xlsx'), overwrite = TRUE)
##
Statistics <- read.xlsx(data, sheet = "Statistic")
# Update statistics
Statistics$Value[Statistics$Statistic == "t-statistic long"] <- coef_biv$betaL / sqrt(sig_biv$sigL2)
Statistics$Value[Statistics$Statistic == "t-statistic short (Matlab)"] <- coef_biv$betaS / sqrt(sig_biv$sigS2)
Statistics$Value[Statistics$Statistic == "Correlation between long and short"] <- sig_biv$sigLS / sqrt(sig_biv$sigL2 * sig_biv$sigS2)
# Add new statistics
R2ZXQ <- (t(MqX) %*% MqZ %*% solve(t(MqZ) %*% MqZ) %*% t(MqZ) %*% MqX) / (t(MqX) %*% MqX)
R2ZYQ <- (t(MqY) %*% MqZ %*% solve(t(MqZ) %*% MqZ) %*% t(MqZ) %*% MqY) / (t(MqY) %*% MqY)
MxqZ <- Z - XQ %*% solve(t(XQ) %*% XQ) %*% t(XQ) %*% Z
normMqZ2 <- norm(MqZ %*% solve(t(MxqZ) %*% MxqZ) %*% t(MxqZ) %*% Y, "F")^2
new_stats <- data.frame(
Statistic = c(
"(Matlab) Betahat long", "(Matlab) Betahat short", "(Matlab) norm(MqY)^2", "(Matlab) norm(MxqY)^2",
"(Matlab) norm(MqX)^2", "(Matlab) Var(Betahat long)", "(Matlab) Cov(Betahat long, Betahat short)",
"(Matlab) Var(Betahat short)", "(Matlab) R-squared of Z on X given Q", "(Matlab) R-squared of Z on Y given Q",
"(Matlab) norm(MqZ*Long coefficient)^2"
),
Value = c(
coef_biv$betaL, coef_biv$betaS, norm(MqY, "F")^2, norm(MxqY, "F")^2, norm(MqX, "F")^2,
sig_biv$sigL2, sig_biv$sigLS, sig_biv$sigS2,
R2ZXQ,
R2ZYQ,
normMqZ2
)
)
# Append new statistics
Statistics <- rbind(Statistics, new_stats)
# Write the updated statistics to Excel
wb <- loadWorkbook(data)
addWorksheet(wb, sheetName = "Matlab")
writeData(wb, sheet = "Matlab", x = Statistics, colNames = TRUE, rowNames = FALSE)
saveWorkbook(wb, file = data, overwrite = TRUE)
# Generate emptab.csv
rm(list = ls())
library(openxlsx)
## Set working directory here
directory_home <- "/Users/eddiewu/Documents/Mon_travail/MY_PHD/Soonwoo/proj_many_controls/econ_replication/li_muller_2021_in_R"
setwd(directory_home)
output_path <- paste0(directory_home, "/my_output")
file <- file.path(output_path, "Bivariatedata1.xlsx")
df <- read.xlsx(file, sheet = "Matlab")
out <- c()
out[1:3] <- df[1:3, "Value"]
out[4] <- df[df$Statistic == "R-squared of Z on X given Q", "Value"]
out[5] <- df[df$Statistic == "(Matlab) Betahat long", "Value"]
out[6] <- df[df$Statistic == "(Matlab) Betahat short", "Value"]
out[7] <- df[df$Statistic == "(Matlab) norm(MxqY)^2", "Value"]
out[8] <- df[df$Statistic == "(Matlab) norm(MqY)^2", "Value"]
out[9] <- df[df$Statistic == "(Matlab) norm(MqX)^2", "Value"]
out[10] <- df[df$Statistic == "(Matlab) Var(Betahat long)", "Value"]
out[11] <- df[df$Statistic == "(Matlab) Cov(Betahat long, Betahat short)", "Value"]
out[12] <- df[df$Statistic == "(Matlab) Var(Betahat short)", "Value"]
out <- data.frame(value = out)
save_file <- file.path(output_path, "emptab.csv")
write.table(out, file = save_file, sep = ",", row.names = FALSE, col.names = FALSE)
rm(list = ls())
library(stats)
library(ggplot2)
## Set working directory here
directory_home <- "/Users/eddiewu/Documents/Mon_travail/MY_PHD/Soonwoo/proj_many_controls/econ_replication/li_muller_2021_in_R"
setwd(directory_home)
output_path <- paste0(directory_home, "/my_output")
cv_path <- paste0(directory_home, "/critical_values")
## Get critical values and define getcv() function
cvtab <- list(read.table(file.path(cv_path, "cvmat_1.txt")),
read.table(file.path(cv_path, "cvmat_5.txt")),
read.table(file.path(cv_path, "cvmat_10.txt")))
getcv <- function(j, kg, wb) {
n <- 40
x <- c(0.5 * (0.5 * log(kg^2 + wb^2) / log(200.0) + 1), 2 * atan(kg / wb) / pi)
x <- pmin(pmax(x, 1/n), (n - 1)/n)
i <- floor(n * x)
w <- n * x - i
wc <- 1 - w
out <- wc[1] * wc[2] * cvtab[[j]][i[1], i[2]] +
w[1] * wc[2] * cvtab[[j]][i[1] + 1, i[2]] +
wc[1] * w[2] * cvtab[[j]][i[1], i[2] + 1] +
w[1] * w[2] * cvtab[[j]][i[1] + 1, i[2] + 1]
return(out)
}
getcv(2, 1.3, 3.0)
### Define getLRr() function
minimize_x0 <- function(y1, y2, kg) {
objective <- function(g) {
y1^2 + (y2 - g)^2
}
out <- optimize(objective, c(-kg, kg))
return(out$objective)
}
minimize_x1 <- function(y1, y2, kg, wb) {
objective <- function(param) {
g <- param[1]
b <- param[2]
(y1 - b)^2 + (y2 - wb * b - g)^2
}
res <- optim(c(0, 0), objective, method = "L-BFGS-B", lower = c(-kg, -Inf), upper = c(kg, Inf))
return(res$value)
}
getLRr <- function(y1, y2, kg, wb) {
x0 <- minimize_x0(y1, y2, kg)
x1 <- minimize_x1(y1, y2, kg, wb)
return(x0 - x1)
}
# Define bhat
bhat <- function(y1, y2, kg, wb) {
if (
( y1 < 0 && (
( kg + wb * y1 >= y2 && ( (wb * y1 < y2 && y2 < 0) || y2 > 0 ) ) ||
( wb * y1 > y2 && (kg + y2 > wb * y1) && y2 < 0 )
)
) ||
( y1 > 0 && (
( y2 > 0 && (
( kg + wb * y1 >= y2 && wb * y1 < y2 ) || ( wb * y1 > y2 && kg + y2 > wb * y1 )
)
) ||
(y2 < 0 && kg + y2 > wb * y1)
)
)
) {
return(y1)
}
else if (kg + wb * y1 < y2) {
return(((-kg * wb) + y1 + (wb * y2)) / (1 + wb^2))
}
else if (kg + y2 <= wb * y1) {
return((y1 + wb * (kg + y2)) / (1 + wb^2))
}
else {
return(NA)
}
}
### Macchiavello settings
iemp <- 1
kmax <- .35
omfac <- 4
fzind <- 4
### Define variables from emptab
file <- file.path(output_path, "emptab.csv")
emptab <- read.csv(file, header = F)
bs <- emptab[6, iemp]
bl <- emptab[5, iemp]
Om11 <- emptab[10, iemp]
Om12 <- emptab[11, iemp]
Om22 <- emptab[12, iemp]
compute_Kdel <- function(kappa) {
return( kappa * sqrt(emptab[1, iemp]) * sqrt(emptab[4, iemp] / emptab[9, iemp]) )
}
# Kdel <- compute_Kdel(kappa)
Omr <- Om12 / sqrt(Om11 * Om22)
omsd <- sqrt(Om11 * Om22 - Om12^2)
compute_kg <- function(kappa) {
return(compute_Kdel(kappa) * sqrt(Om11) / omsd)
}
# kg <- compute_kg(kappa)
wb <- (Om11 - Om12)/omsd;
y1 <- bl / sqrt(Om11)
y2 <- (wb / sqrt(Om11) - sqrt(Om11) / omsd) * bl + sqrt(Om11) / omsd * bs
ysign = 1
Omi = solve(rbind(c(Om11, Om12), c(Om12, Om22)))
### Compute data for plotting
pdata <- c()
for (kappa in seq(0, kmax, kmax/50)) {
if (kappa == 0) {
kappa <- 0.0000001
}
cvx <- numeric(3)
kg <- compute_kg(kappa)
for (j in 1:3) {
cvx[j] <- getcv(j, kg, wb)
}
roots <- numeric()
for (j in 1:3) {
for (ix in seq(-1, 1, 2)) {
equation <- function(b) {
return( getLRr(y1 - b, y2 - wb * b, kg, wb) - cvx[j] )
}
b_init <- bhat(y1, y2, kg, wb) + 2 * ix
print(b_init)
root <- uniroot(equation, c(b_init-2, b_init+2))$root
roots <- c(roots, root)
}
}
pdata <- rbind(pdata, c(kappa, roots))
}
### Put into a list of matrices
xx <- list()
for (i in 2:ncol(pdata)) {
temp <- matrix(nrow = nrow(pdata), ncol = 2)
for (j in 1:nrow(pdata)) {
temp[j, ] <- c(pdata[j, 1], sqrt(Om11) * pdata[j, i])
}
xx[[i - 1]] <- temp
}
temp <- matrix(nrow = nrow(pdata), ncol = 2)
for (j in 1:nrow(pdata)) {
temp[j, ] <- c(pdata[j, 1], 0.5 * sqrt(Om11) * (pdata[j, 4] + pdata[j, 5]))
}
xx <- append(xx, list(temp), after = 0)
### Interpolation
temp <- xx[[fzind]]
x <- temp[, 1]
y <- temp[, 2]
f <- splinefun(x, y, method = "monoH.FC")
kstar <- uniroot(f, c(0, 0.5))$root
temp <- list(
matrix( c(kstar, bl - 0.8 * omfac * sqrt(Om11), kstar, bl + 0.98 * omfac * sqrt(Om11)),
nrow = 2,
byrow = TRUE))
xx <- append(xx, temp)
### Final graph plot
plot <- ggplot() +
geom_line(aes(x = xx[[1]][,1], y = xx[[1]][,2]), linewidth = 0.7) +
geom_line(aes(x = xx[[2]][,1], y = xx[[2]][,2]), linetype = 3) +
geom_line(aes(x = xx[[3]][,1], y = xx[[3]][,2]), linetype = 3) +
geom_line(aes(x = xx[[4]][,1], y = xx[[4]][,2])) +
geom_line(aes(x = xx[[5]][,1], y = xx[[5]][,2])) +
geom_line(aes(x = xx[[6]][,1], y = xx[[6]][,2]), linetype = 4) +
geom_line(aes(x = xx[[7]][,1], y = xx[[7]][,2]), linetype = 4) +
geom_line(aes(x = xx[[8]][,1], y = xx[[8]][,2]), linetype = 2) +
geom_text(aes(x = xx[[8]][1,1], label="k*_{LR}", y = xx[[8]][1,2]), colour="black") +
geom_hline(yintercept = 0, linewidth = 0.2) +
geom_vline(xintercept = 0, linewidth = 0.2) +
xlab(NULL) +
ylab(NULL) +
theme_minimal()
plot
ggsave(file.path(output_path, "macchiavello.pdf"), plot)
source("~/Documents/Mon_travail/MY_PHD/Soonwoo/proj_many_controls/econ_replication/li_muller_2021_in_R/main.R")
